# The First Semester

Halfway through the first semester, our level designer, Sam, had been working on greyboxing the level, and our AI programmer, Sam, had created early versions of the enemies. The obvious next steps were to add enemy spawners and manage player progression. After talking with Sam (the level designer), we came up with some basic goals for the encounter management system. It needed to spawn multiple waves of enemies, from multiple locations, in a combat arena. It then needed to track all the enemies in the arena, including pre-placed enemies, and halt the player's progression until they clear all the enemies.

To implement this initial iteration, I started with a simple box trigger Actor which I called the EncounterArea. This object would register and track placed and spawned enemies, count how many waves were left in the encounter, and close all the door objects it controlled until the encounter was cleared. I also created a Spawner object and made it spawn a wave of enemies when the player entered the trigger, or cleared the previous wave. These objects together satisfied the initial requirements: when the player walked into the EncounterArea trigger, the doors would close and a wave of enemies would begin spawning from the Spawners that had been placed around the area. Once all the enemies in a wave were killed, the next wave would spawn. Then, once the player had cleared enough waves, the doors would open again and the player could move on.

It was a decent start, but after working with it for a while, Sam (the level designer) felt aspects of it were too restrictive. In its current state, Spawners would spawn the same number of the same type of enemy each wave. He wanted individual waves to be more varied, so I reworked how spawners were configured. I stored an array of enemy class references in a WaveData structure, and stored an array of WaveDatas in the Spawner class. When it was time to spawn a wave, the Spawner would spawn each enemy type listen in the array, and then increment the current wave counter by one. If the current wave was outside the bounds of the WaveData array, it stopped attempting to spawn a new wave when the previous wave was defeated. The encounter was then cleared once all the Spawners in a given EncounterArea ran out of waves to spawn. This meant that an EncounterArea could have a set of spawners with wildly different wave configurations and even numbers of waves and still function just the same, and it enabled Sam to make engagements much more engaging.

# The Second Semester

$MEDIA_ONLY$

The system worked well for Greenlight, but in the second semester, we wanted to expand its functionality even further. I wanted to add a variety of objective types to the game, so that the player could experience a wider variety of challenges. To accomplish this, I created a new Component type which would attach to the EncounterArea Actor and track the completion of the objective. I added integration to the EncounterArea in the BaseObjective class, and allowed the Check Objective function to be overriden so that sub-classes can implement their own objective criteria. Using this system, I created Objective components that require a player to clear a set number of waves, or survive for a set amount of time, or to activate switches placed around the area. Along the way, the wave system had to be changed a bit: spawners now cycle through all their set waves, and stop spawning altogether when the objective is cleared. The player must still defeat the final wave before advancing.

My teammates needed some additional functionality from this system to accomplish their second-semester goals as well. Sam (the AI programmer) wanted to make the enemies fight in formations, where some enemies fight more in the player's face, while others hang back and provide supporting fire. This behavior needed to consider **all** currently loaded enemies, but at that point the only way to do that was to loop through each Encounter Area's list of enemies--not very efficient! To streamline the process, I created an EnemyManager Component class and attached it to the GameMode class used in the levels. This class stores a list of references to each enemy in the level that is updated each time an enemy spawns or dies. Each enemy reference has an accompanying struct which holds data that needs to be accessed by other objects in the level. Sam's AI systems could track the enemies' aggression levels this way, and the new organization helped make other gameplay systems like SYNC targeting more efficient too.

Finally, the narrative team wanted the final encounter of the game to end with a dialogue clip. Fortunately, my teammate, Nick, had already implemented a robust dialogue system, so it was a simple matter of triggering a new dialogue instance at the end of an encounter. I wanted to implement it quickly, so I added a flag to the EncounterArea system for "Play Dialogue After Encounter", and added configurable dialogue parameters. If the flag was checked, the player would see and hear the final dialogue of the game after they defeat the evil, rogue AI, Syntell, tying the whole game of _SYNC_ to a close.
